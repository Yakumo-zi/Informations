# Go基础

## defer实现机制

* 堆上分配：整个分配到堆上，被GC管，加重GC负担，性能比较差
* 栈上分配：分配到goroutine栈上，不需要被GC管理，比堆上分配性能提升30%
* 开放编码（性能最好）：内联代码，将defer注册的内容放到函数最后，启用条件：
  * defer数量少于等于8个：**用一个byte来记录那些defer要执行**
  * defer关键字不能再循环中执行：**编译时不知道有多少个defer**
  * 函数的return语句与defer语句的乘积小于或者等于15个：硬性规定

在Go里面，尽量让对象分配到栈上，分配到堆上就叫做内存逃逸。

## 切片扩容：

原理：重新分配一段连续内存，把原本的数据拷贝过去

扩容系数：

* 容量小于256，两倍扩容（低版本的分界线是1024）
* 大于等于256，1.25倍扩容

为什么一开始是两倍扩容，后面是1.25倍扩容？

扩多了浪费内存，扩少了频繁扩容。

为什么低版本是1024，高版本是256？

跟容量有关的问题，都需要考虑，按照什么系数来扩容，需要取得一个权衡，系数大了浪费，系数小了频繁扩容。

## 跨域问题

协议，域名，端口任意一个不同，都是跨域请求，如果不做额外处理， 没有办法**通过浏览器**发送跨域请求。

浏览器会发送一个`OPTION`方法的prelight方法，来请求服务器允许那些方法和IP以及对应的Headers进行跨域请求。

